#!/bin/bash

action=$1
shift

if [ "$action" = "usage" ]; then
    echo "    $(basename $0) [TERM...]"
    echo "      Show dependency tree of tasks containing TERM."
    echo "      If no TERM provided, displays all tasks with dependencies."
    echo ""
    exit
elif [ "$action" = "list" -o "$2" = "debug" ]; then
    export TODOTXT_VERBOSE=0
    export post_filter_command="grep -e '^ \\{0,\\}$1 '" # Note: '^ *$1' doesn't match for $1="1". 
    _list "$TODO_FILE"
    exit
fi

referencePattern='^w:[0-9]+$'

awk -v referencePattern=$referencePattern -v callback=$0 '
    BEGIN { FS = "[ \t]" }
    {
        for (i = 1; i <= NF; ++i) {
            if ($i ~ referencePattern) {
                match($i, /[0-9]+/)
                s = substr($i, RSTART, RLENGTH) + 0
                p = NR
                # print p "->" s

                if (!(p in pcnt))
                    pcnt[p] = 0
                ++pcnt[s]
                slist[p, ++scnt[p]] = s
            }
        }
    }
    END {
        WIDTH = length(NR "")
        for (node in pcnt) {
            ++nodecnt
            if (pcnt[node] == 0)
                rtsort(node)
        }
        if (pncnt != nodecnt)
            print "error: input contains a cycle"

        # Find all roots (i.e. nodes without a predecessor). 
        for (i = pncnt; i > 0; --i) {
            node = sorted[i]
            if (pcnt[node] == 0) {
                # Insert into rilist so that it is sorted by the nodes that the indices are referring to. 
                rilist[++rcnt] = i
                for (j = rcnt; j > 1 && (sorted[rilist[j-1]] + 0) > (sorted[rilist[j]] + 0); j--) {
                    # Swap rilist[j-1] and rilist[j]. 
                    t = rilist[j-1]; rilist[j-1] = rilist[j]; rilist[j] = t
                }
            }
        }
        for (ri = 1; ri <= rcnt; ++ri)
            printtree(rilist[ri], 0)
    }
    function rtsort(node,     i, s) {
        visited[node] = 1
        for (i = scnt[node]; i > 0; --i)
            if (visited[s = slist[node, i]] == 0)
                rtsort(s)
            else if (visited[s] == 1)
                printf("error: nodes %s and %s are in a cycle\n", s, node)
            visited[node] = 2
            sorted[++pncnt] = node
    }
    function gettask1(num) {
        return sprintf("%0" WIDTH "d", num)
    }
    function gettask(num,     taskcall, task) {
        if (taskcache[num] != "")
            return taskcache[num]
        taskcall = callback " list " num
        taskcall | getline task
        taskcache[num] = task
        return task
    }
    function printtree(i, level,     node, j, k) {
        node = sorted[i]
        # printf("%s%s=%s(%s)\n", level, i, node, scnt[node])
        printf("%" (level * (WIDTH + 1)) "s%s\n", "", gettask(node))
        if (scnt[node] > 0) {
            for (j = i - 1; j >= 0; --j)
                for (k = 1; k <= scnt[node]; ++k)
                    if (sorted[j] == slist[node, k])
                        printtree(j, (level + 1))
        }
    }' "$TODO_FILE"
