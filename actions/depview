#!/bin/bash

action=$1
shift

[ "$action" = "usage" ] && {
    echo "    $(basename $0) [TERM...]"
    echo "      Show dependency tree of tasks containing TERM."
    echo "      If no TERM provided, displays all tasks with dependencies."
    echo ""
    exit
}

referencePattern='^w:[0-9]+$'

awk -v referencePattern=$referencePattern '
    BEGIN { FS = "[ \t]" }
    {
        for (i = 1; i <= NF; ++i) {
            if ($i ~ referencePattern) {
                match($i, /[0-9]+/)
                s = substr($i, RSTART, RLENGTH) + 0
                p = NR
                # print p "->" s

                if (!(p in pcnt))
                    pcnt[p] = 0
                ++pcnt[s]
                slist[p, ++scnt[p]] = s
            }
        }
    }
    END {
        WIDTH = length(NR " ")
        for (node in pcnt) {
            ++nodecnt
            if (pcnt[node] == 0)
                rtsort(node)
        }
        if (pncnt != nodecnt)
            print "error: input contains a cycle"

        # Find all roots (i.e. nodes without a predecessor). 
        for (i = pncnt; i > 0; --i) {
            node = sorted[i]
            if (pcnt[node] == 0) {
                # Insert into rilist so that it is sorted by the nodes that the indices are referring to. 
                rilist[++rcnt] = i
                for (j = rcnt; j > 1 && (sorted[rilist[j-1]] + 0) > (sorted[rilist[j]] + 0); j--) {
                    # Swap rilist[j-1] and rilist[j]. 
                    t = rilist[j-1]; rilist[j-1] = rilist[j]; rilist[j] = t
                }
            }
        }
        for (ri = 1; ri <= rcnt; ++ri)
            printtree(rilist[ri], 0)
        
        printf("\n")
    }
    function rtsort(node,     i, s) {
        visited[node] = 1
        for (i = scnt[node]; i > 0; --i)
            if (visited[s = slist[node, i]] == 0)
                rtsort(s)
            else if (visited[s] == 1)
                printf("error: nodes %s and %s are in a cycle\n", s, node)
            visited[node] = 2
            sorted[++pncnt] = node
    }
    function gettask(num) {
        return num
    }
    function printtree(i, level,     node, j, k) {
        node = sorted[i]
        # printf("%s%s=%s(%s)\n", level, i, node, scnt[node])
        printf("%" (level * (WIDTH + 1)) "s%0" WIDTH "d\n", "", gettask(node))
        if (scnt[node] > 0) {
            for (j = i - 1; j >= 0; --j)
                for (k = 1; k <= scnt[node]; ++k)
                    if (sorted[j] == slist[node, k])
                        printtree(j, ++level)
        }
    }' "$TODO_FILE"
