#!/bin/bash

action=$1
shift

[ "$action" = "usage" ] && {
    echo "    $(basename $0) del|trash [--hard] ITEM# DUPITEM#[, DUPITEM#, ...]"
    echo "      Trash the tasks on line(s) DUPITEM# with a comment of"
    echo "      \"dup of ITEM#\". Use this when the tasks are identical and."
    echo "      were added without knowledge of the existing task."
    echo "    $(basename $0) goal GOAL ITEM#[, ITEM#, ...]"
    echo "      Bidirectionally join the tasks on lines ITEM# together"
    echo "      as contradependent tasks. Use this when the tasks are"
    echo "      different takes on achieving the same goal."
    echo "    $(basename $0) link ITEM# ITEM#[, ITEM#, ...]"
    echo "      Bidirectionally cross-link the tasks on lines ITEM# together"
    echo "      as duplicate tasks. Use this when doing one task should do all others,"
    echo "      too."
    echo ""
    exit
}

errmsg="usage: $TODO_SH $(basename $0) (del|trash [--hard])|(goal GOAL)|link ITEM# ITEM#[, ITEM#, ...]"

isHard=
case $1 in
    del|trash)
        subaction='trash'
        shift
        if [ "$1" = '--hard' ]; then
            isHard='true'
            shift
        fi

        [ $# -ge 2 ] || die "$errmsg"
        item=$1
        shift
        dupItems=$*
        ;;
    goal)
        subaction='append'
        shift

        [ $# -ge 2 ] || die "$errmsg"
        goal=$1
        # Ensure that an actual GOAL is given, and do not just pick a following
        # ITEM# as the GOAL. 
        [[ "$goal" =~ ^[,0-9]+$ ]] && die "$errmsg"
        shift
        dupItems=$*
        ;;
    link)
        subaction='link'
        shift

        [ $# -ge 2 ] || die "$errmsg"
        dupItems=$*
        ;;
    *)
        die "$errmsg"
        ;;
esac

# Split multiple duplicates, if comma separated change to whitespace separated. 
for dupItem in ${dupItems//,/ }
do
    case $subaction in
        trash)
            "$TODO_FULL_SH" comment $dupItem "dup of $item"
            eval 'RECURSIVE_DO=true "$TODO_FULL_SH" trash' ${isHard:+--hard} '$dupItem' || exit $?
            ;;
        append)
            # Do not pass leading space; the append action adds that itself. 
            "$TODO_FULL_SH" command append $dupItem "j:$goal" || exit $?
            ;;
        link)
            "$TODO_FULL_SH" link $dupItem "${dupItems/$dupItem/}" || exit $?
            ;;
        *)
            die "ASSERT: Unknown subaction \"${subaction}\""
            ;;
    esac
done

if [ "$subaction" = 'append' ]; then
    # The append action just prints the resulting task, so add a proper final
    # message myself. 
    echo "TODO: ${dupItems// /,} now share the goal $goal"
fi
