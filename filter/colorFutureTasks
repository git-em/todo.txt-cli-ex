#!/bin/bash
if [ $TODOTXT_PLAIN -eq 0 ]; then
export COLOR_DUE_FUTURE='(FUTURE)'
export COLOR_DUE_TODAY='(TODAY)'
export COLOR_DUE_1DAY='(1DAY)'
export COLOR_DUE_2DAY='(2DAY)'
export COLOR_DUE_3DAY='(3DAY)'
export COLOR_DUE_1WEEK='(1WEEK)'
export COLOR_DUE_2WEEK='(2WEEK)'
export COLOR_DUE_3WEEK='(3WEEK)'
export COLOR_DUE_1MONTH='(1MONTH)'
export COLOR_DUE_2MONTH='(2MONTH)'
export COLOR_DUE_3MONTH='(3MONTH)'
export COLOR_DUE_1YEAR='(1YEAR)'
export COLOR_DUE_2YEAR='(2YEAR)'
export COLOR_DUE_3YEAR='(3YEAR)'
export COLOR_DUE_OLDEST='(OLDEST)'

export COLOR_LATEST_FUTURE='!OVERDUE!'
export COLOR_LATEST_TODAY='!TODAY!'
export COLOR_LATEST_1WEEK='!1WEEK!'
export COLOR_LATEST_1MONTH='!1MONTH!'
export COLOR_LATEST_OLDEST='!OLDEST!'

awk --re-interval -v date=$1 '
function highlight(colorVar,      color) {
    color = ENVIRON[colorVar]
    gsub(/\\+033/, "\033", color)
    return color
}
function highlightend(colorVar, defaultColor,      color) {
    color = highlight(colorVar "_END")
    if (color == "") {
        return defaultColor
    } else {
        return color
    }
}
function getLineColor(      hl) {
    if (match($0, /[0-9]+ /) > 1) {
        return substr($0, 1, RSTART - 1)
    } else {
        return highlight("DEFAULT")
    }
}
function getSpanClass(daySpan, what,      class) {
    # We do not want the fallback to older span classes for future due dates, so
    # they are handled specially. 
    if (daySpan < 0) {
        class = "COLOR_" what "_FUTURE"
        return (ENVIRON[class] == "" ? "" : class)
    }

    # Find the bucket where the span falls into... 
    for (i = 1; i <= spanNum; i++) {
        if (daySpan < spanNumbers[i])
            break
    }

    # ...then find the next bucket for which an actual color definition actually
    # exists, looking into progressively larger spans of time. (I.e. if there is
    # no special highlighting for "due in 3 days", we use the highlighting for
    # "due in 1 week" instead.) 
    for (j = i; j <= spanNum + 1; j++) {
        class = "COLOR_" what "_" spanNames[j]
        if (ENVIRON[class] != "")
            return class
    }
}
BEGIN {
    spanNum =   split("         1    2    3     7    14    21     30     60     91   365   730  1095   1461", spanNumbers)
                split("TODAY 1DAY 2DAY 3DAY 1WEEK 2WEEK 3WEEK 1MONTH 2MONTH 3MONTH 1YEAR 2YEAR 3YEAR OLDEST", spanNames)

    if (date == "") {
        threshold = mktime(strftime("%Y %m %d 00 00 00", systime()))
    } else {
        threshold = mktime(gensub(/([0-9]{4})-([0-9]{2})-([0-9]{2})/, "\\1 \\2 \\3 00 00 00", "", date))
    }
}
# Existing line highlightings (i.e. prioritized or done tasks) have precedence
# over any time-based rules. 
{
    lineColor = getLineColor()
}
# Highlight tasks with a latest date. This has precedence over a due date. 
/ T:[0-9]{4}-[0-9]{2}-[0-9]{2}/ {
    date = mktime(gensub(/^.* T:([0-9]{4})-([0-9]{2})-([0-9]{2}).*$/, "\\1 \\2 \\3 00 00 00", ""))

    # Highlight tasks with a latest date, depending on how long until the date. 
    daySpan = int((date - threshold) / 86400)
    latestClass = getSpanClass(daySpan, "LATEST")
    if (lineColor == highlight("DEFAULT")) {
        # No existing line color, apply to entire line. 
        lineColor = highlight(latestClass)
        $0 = highlight(latestClass) $0 highlightend(latestClass, highlight("DEFAULT"))
    } else {
        # The line is already colored, only highlight the latest date itself. 
        $0 = gensub(/ (T:[0-9]{4}-[0-9]{2}-[0-9]{2})/, " " highlight(latestClass) "\\1" highlightend(latestClass, lineColor), "")
    }
}
# Filter out tasks due in the future, highlight the time since tasks have become
# due. 
/ t:[0-9]{4}-[0-9]{2}-[0-9]{2}/ {
    date = mktime(gensub(/^.* t:([0-9]{4})-([0-9]{2})-([0-9]{2}).*$/, "\\1 \\2 \\3 00 00 00", ""))
    if (date > threshold) {
        # Suppress tasks that are scheduled in the future. 
        next
    }

    # Highlight scheduled tasks, depending on how long they are due now. 
    daySpan = int((threshold - date) / 86400)
    dueClass = getSpanClass(daySpan, "DUE")
    if (lineColor == highlight("DEFAULT")) {
        # No existing line color, apply to entire line. 
        lineColor = highlight(dueClass)
        $0 = highlight(dueClass) $0 highlightend(dueClass, highlight("DEFAULT"))
    } else {
        # The line is already colored, only highlight the due date itself. 
        $0 = gensub(/ (t:[0-9]{4}-[0-9]{2}-[0-9]{2})/, " " highlight(dueClass) "\\1" highlightend(dueClass, lineColor), "")
    }
}
{ print }
'
else
awk --re-interval -v date=$1 '
BEGIN {
    if (date == "") {
        threshold = mktime(strftime("%Y %m %d 00 00 00", systime()))
    } else {
        threshold = mktime(gensub(/([0-9]{4})-([0-9]{2})-([0-9]{2})/, "\\1 \\2 \\3 00 00 00", "", date))
    }
}
/ t:[0-9]{4}-[0-9]{2}-[0-9]{2}( |$)/ {
    date = mktime(gensub(/^.* t:([0-9]{4})-([0-9]{2})-([0-9]{2})( .*)?$/, "\\1 \\2 \\3 00 00 00", ""))
    if (date > threshold) {
        next
    }
}
{ print }
'
fi
